/*
 * Copyright (c) 2008-2012, Matthias Mann
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Matthias Mann nor the names of its contributors may
 *       be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

using System;
using System.IO;
using System.Text;

namespace XNATWL.TextAreaModel
{
    /**
     * This class is a scanner generated by 
     * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
     * on 03.01.12 11:50 from the specification file
     * <tt>parser.flex</tt>
     */
    class Parser
    {

        /** This character denotes the end of file */
        public static int YYEOF = -1;

        /** initial size of the lookahead buffer */
        private static int ZZ_BUFFERSIZE = 16384;

        /** lexical states */
        public static int YYSTRING1 = 6;
        public static int YYINITIAL = 0;
        public static int YYSTYLE = 2;
        public static int YYVALUE = 4;
        public static int YYSTRING2 = 8;

        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         *                  at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        //  private static int ZZ_LEXSTATE[] = {
        //     0,  0,  1,  1,  2,  2,  3,  3,  4, 4
        //  };

        /** 
         * Translates characters to character classes
         */
        private static int[] ZZ_CMAP_PACKED = new int[] { 9, 0, 1, 3, 1, 2, 1, 0, 1, 3, 1, 1, 18, 0, 1, 3, 1, 0, 1, 19, 1, 12, 3, 0, 1, 18, 2, 0, 1, 5, 1, 0, 1, 10, 1, 6, 1, 9, 1, 4, 10, 8, 1, 13, 1, 17, 2, 0, 1, 11, 1, 0, 1, 14, 26, 7, 4, 0, 1, 7, 1, 0, 26, 7, 1, 15, 1, 0, 1, 16, 65410, 0 };

        private static char[] ZZ_CMAP = ZZUnpackCMap(ZZ_CMAP_PACKED);

        /** 
         * Translates DFA states to action switch labels.
         */

        private static int[] ZZ_ACTION_PACKED_0 = new int[] { 5, 0, 1, 1, 1, 2, 1, 1, 1, 3, 1, 1, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 1, 10, 1, 11, 2, 12, 1, 1, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 16, 1, 20, 1, 16, 1, 21, 4, 0 };
        private static int[] ZZ_ACTION = ZZUnpackAction();

        private static int[] ZZUnpackAction()
        {
            int[] result = new int[100];
            ZZUnpackAction(ZZ_ACTION_PACKED_0, 0, result);
            return result;
        }

        private static int ZZUnpackAction(int[] packed, int offset, int[] result)
        {
            int i = 0;       /* index in packed string  */
            int j = offset;  /* index in unpacked array */
            int l = packed.Length;
            while (i < l)
            {
                int count = packed[i++];
                int value = packed[i++];
                do result[j++] = value; while (--count > 0);
            }
            return j;
        }


        /** 
         * Translates a state to a row index in the transition table
         */

        private static int[] ZZ_ROWMAP_PACKED_0 = new int[] { 0, 0, 0, 20, 0, 40, 0, 60, 0, 80, 0, 100, 0, 120, 0, 140, 0, 100, 0, 160, 0, 180, 0, 100, 0, 100, 0, 100, 0, 100, 0, 100, 0, 100, 0, 100, 0, 200, 0, 100, 0, 220, 0, 240, 0, 100, 0, 100, 0, 260, 0, 100, 0, 100, 0, 100, 0, 280, 0, 100, 0, 300, 0, 100, 0, 320, 0, 340, 0, 360, 0, 380 };
        private static int[] ZZ_ROWMAP = ZZUnpackRowMap();

        private static int[] ZZUnpackRowMap()
        {
            int[] result = new int[36];
            ZZUnpackRowMap(ZZ_ROWMAP_PACKED_0, 0, result);
            return result;
        }

        private static int ZZUnpackRowMap(int[] packed, int offset, int[] result)
        {
            int i = 0;  /* index in packed string  */
            int j = offset;  /* index in unpacked array */
            int l = packed.Length;
            while (i < l)
            {
                int high = packed[i++] << 16;
                result[j++] = high | packed[i++];
            }
            return j;
        }

        /** 
         * The transition table of the DFA
         */

        private static int[] ZZ_TRANS_PACKED_0 = new int[] { 1, 6, 3, 7, 1, 8, 1, 9, 1, 10, 1, 11, 1, 6, 1, 12, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 5, 6, 1, 19, 2, 20, 1, 8, 1, 6, 1, 21, 1, 22, 5, 6, 1, 23, 2, 6, 1, 24, 3, 6, 16, 25, 1, 24, 1, 26, 1, 27, 1, 28, 18, 29, 1, 30, 1, 29, 19, 31, 1, 32, 21, 0, 3, 7, 21, 0, 1, 33, 21, 0, 1, 11, 18, 0, 3, 11, 13, 0, 1, 20, 24, 0, 1, 22, 18, 0, 3, 22, 11, 0, 16, 25, 4, 0, 18, 29, 1, 0, 1, 29, 19, 31, 1, 0, 5, 34, 1, 35, 19, 34, 1, 36, 14, 34, 4, 0, 1, 20, 1, 35, 14, 0, 4, 34, 1, 20, 1, 36, 14, 34 };
        private static int[] ZZ_TRANS = ZZUnpackTrans();

        private static int[] ZZUnpackTrans()
        {
            int[] result = new int[400];
            ZZUnpackTrans(ZZ_TRANS_PACKED_0, 0, result);
            return result;
        }

        private static int ZZUnpackTrans(int[] packed, int offset, int[] result)
        {
            int i = 0;       /* index in packed string  */
            int j = offset;  /* index in unpacked array */
            int l = packed.Length;
            while (i < l)
            {
                int count = packed[i++];
                int value = packed[i++];
                value--;
                do result[j++] = value; while (--count > 0);
            }
            return j;
        }

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
         */
        private static int[] ZZ_ATTRIBUTE_PACKED_0 = new int[] { 5, 0, 1, 9, 2, 1, 1, 9, 2, 1, 7, 9, 1, 1, 1, 9, 2, 1, 2, 9, 1, 1, 3, 9, 1, 1, 1, 9, 1, 1, 1, 9, 4, 0 };

        private static int[] ZZ_ATTRIBUTE = ZZUnpackAttribute();

        private static int[] ZZUnpackAttribute()
        {
            int[] result = new int[36];
            ZZUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, 0, result);
            return result;
        }

        private static int ZZUnpackAttribute(int[] packed, int offset, int[] result)
        {
            int i = 0;       /* index in packed string  */
            int j = offset;  /* index in unpacked array */
            int l = packed.Length;
            while (i < l)
            {
                int count = packed[i++];
                int value = packed[i++];
                do result[j++] = value; while (--count > 0);
            }
            return j;
        }

        /** the input device */
        private StreamReader _zzReader;

        /** the current state of the DFA */
        private int _zzState;

        /** the current lexical state */
        private int _zzLexicalState = YYINITIAL;

        /** this buffer contains the current text to be matched and is
            the source of the yytext() string */
        private char[] _zzBuffer = new char[ZZ_BUFFERSIZE];

        /** the textposition at the last accepting state */
        private int _zzMarkedPos;

        /** the current text position in the buffer */
        private int _zzCurrentPos;

        /** startRead marks the beginning of the yytext() string in the buffer */
        private int _zzStartRead;

        /** endRead marks the last character in the buffer, that has been read
            from input */
        private int _zzEndRead;

        /** number of newlines encountered up to the start of the matched text */
        private int _yyLine;

        /**
         * the number of characters from the last newline up to the start of the 
         * matched text
         */
        private int _yyColumn;

        /** zzAtEOF == true <=> the scanner is at the EOF */
        private bool _zzAtEOF;

        /* user code: */
        internal static int EOF = 0;
        internal static int IDENT = 1;
        internal static int STAR = 2;
        internal static int DOT = 3;
        internal static int HASH = 4;
        internal static int GT = 5;
        internal static int COMMA = 6;
        internal static int STYLE_BEGIN = 7;
        internal static int STYLE_END = 8;
        internal static int COLON = 9;
        internal static int SEMICOLON = 10;
        internal static int ATRULE = 11;

        internal bool _sawWhitespace;

        internal StringBuilder _stringBuilder = new StringBuilder();

        private void Append()
        {
            _stringBuilder.Append(_zzBuffer, _zzStartRead, _zzMarkedPos - _zzStartRead);
        }

        public void Unexpected()
        {
            throw new IOException("Unexpected \"" + YYText() + "\" at line " + _yyLine + ", column " + _yyColumn);
        }

        public void Expect(int token)
        {
            if (YYLex() != token) Unexpected();
        }


        /**
         * Creates a new scanner
         * There is also a java.io.InputStream version of this constructor.
         *
         * @param   in  the java.io.Reader to read input from.
         */
        internal Parser(StreamReader srin)
        {
            this._zzReader = srin;
        }

        /**
         * Unpacks the compressed character translation table.
         *
         * @param packed   the packed character translation table
         * @return         the unpacked character translation table
         */
        private static char[] ZZUnpackCMap(int[] packed)
        {
            char[] map = new char[0x10000];
            int i = 0;  /* index in packed string  */
            int j = 0;  /* index in unpacked array */
            while (i < 72)
            {
                int count = packed[i++];
                char value = (char)(packed[i++]);
                do map[j++] = (char) value; while (--count > 0);
            }
            return map;
        }


        /**
         * Refills the input buffer.
         *
         * @return      <code>false</code>, iff there was new input.
         * 
         * @exception   java.io.IOException  if any I/O-Error occurs
         */
        private bool ZZRefill()
        {

            /* first: make room (if you can) */
            if (_zzStartRead > 0)
            {
                Array.Copy(_zzBuffer, _zzStartRead,
                                 _zzBuffer, 0,
                                 _zzEndRead - _zzStartRead);

                /* translate stored positions */
                _zzEndRead -= _zzStartRead;
                _zzCurrentPos -= _zzStartRead;
                _zzMarkedPos -= _zzStartRead;
                _zzStartRead = 0;
            }

            /* is the buffer big enough? */
            if (_zzCurrentPos >= _zzBuffer.Length)
            {
                /* if not: blow it up */
                char[] newBuffer = new char[_zzCurrentPos * 2];
                Array.Copy(_zzBuffer, 0, newBuffer, 0, _zzBuffer.Length);
                _zzBuffer = newBuffer;
            }

            /* finally: fill the buffer with new input */
            int numRead = _zzReader.Read(_zzBuffer, _zzEndRead, _zzBuffer.Length - _zzEndRead);

            if (numRead > 0)
            {
                _zzEndRead += numRead;
                return false;
            }
            // unlikely but not impossible: read 0 characters, but not at end of stream    
            if (numRead == 0)
            {
                int c = _zzReader.Read();
                if (c == -1)
                {
                    return true;
                }
                else
                {
                    _zzBuffer[_zzEndRead++] = (char)c;
                    return false;
                }
            }

            // numRead < 0
            return true;
        }


        /**
         * Enters a new lexical state
         *
         * @param newState the new lexical state
         */
        public void YYBegin(int newState)
        {
            _zzLexicalState = newState;
        }


        /**
         * Returns the text matched by the current regular expression.
         */
        public String YYText()
        {
            return new String(_zzBuffer, _zzStartRead, _zzMarkedPos - _zzStartRead);
        }


        /**
         * Reports an error that occured while scanning.
         *
         * In a wellformed scanner (no or only correct usage of 
         * yypushback(int) and a match-all fallback rule) this method 
         * will only be called with things that "Can't Possibly Happen".
         * If this method is called, something is seriously wrong
         * (e.g. a JFlex bug producing a faulty scanner etc.).
         *
         * Usual syntax/scanner level error handling should be done
         * in error fallback rules.
         *
         * @param   message  the errormessage to display
         */
        private void ZZScanError(String message)
        {
            throw new Exception(message);
        }


        /**
         * Resumes scanning until the next regular expression is matched,
         * the end of input is encountered or an I/O-Error occurs.
         *
         * @return      the next token
         * @exception   java.io.IOException  if any I/O-Error occurs
         */
        /**
         * Ported using IKVM
         * https://github.com/ikvm-revived/ikvm/blob/develop/LICENSE.md
         * =================
         * 
         * Copyright (C) 2002-2022 Jeroen Frijters, Windward Studios, Jerome Haltom, Shad Storhaug, and contributors.
         * 
         * This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
         * 
         * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
         * 
         * The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
         * Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
         * This notice may not be removed or altered from any source distribution.
        */
        public virtual int YYLex()
        {
            int num = _zzEndRead;
            char[] array = _zzBuffer;
            char[] zZ_CMAP = ZZ_CMAP;
            int[] zZ_TRANS = ZZ_TRANS;
            int[] zZ_ROWMAP = ZZ_ROWMAP;
            int[] zZ_ATTRIBUTE = ZZ_ATTRIBUTE;
            while (true)
            {
                int num2 = _zzMarkedPos;
                int num3 = 0;
                int i;
                for (i = _zzStartRead; i < num2; i++)
                {
                    switch (array[i])
                    {
                        case '\v':
                        case '\f':
                        case '\u0085':
                        case '\u2028':
                        case '\u2029':
                            _yyLine++;
                            _yyColumn = 0;
                            num3 = 0;
                            break;
                        case '\r':
                            _yyLine++;
                            _yyColumn = 0;
                            num3 = 1;
                            break;
                        case '\n':
                            if (num3 != 0)
                            {
                                num3 = 0;
                                break;
                            }
                            _yyLine++;
                            _yyColumn = 0;
                            break;
                        default:
                            num3 = 0;
                            _yyColumn++;
                            break;
                    }
                }
                if (num3 != 0)
                {
                    int num4;
                    if (num2 < num)
                    {
                        num4 = ((array[num2] == '\n') ? 1 : 0);
                    }
                    else if (_zzAtEOF)
                    {
                        num4 = 0;
                    }
                    else
                    {
                        int num5 = (ZZRefill() ? 1 : 0);
                        num = _zzEndRead;
                        num2 = _zzMarkedPos;
                        array = _zzBuffer;
                        num4 = ((num5 == 0 && array[num2] == '\n') ? 1 : 0);
                    }
                    if (num4 != 0)
                    {
                        _yyLine--;
                    }
                }
                int num6 = -1;
                int num7 = num2;
                int num8 = num7;
                _zzStartRead = num7;
                num7 = num8;
                int num9 = num7;
                _zzCurrentPos = num7;
                i = num9;
                _zzState = _zzLexicalState / 2;
                int num11;
                while (true)
                {
                    int num4;
                    if (i < num)
                    {
                        char[] array2 = array;
                        int num10 = i;
                        i++;
                        num11 = array2[num10];
                    }
                    else
                    {
                        if (_zzAtEOF)
                        {
                            num11 = -1;
                            break;
                        }
                        _zzCurrentPos = i;
                        _zzMarkedPos = num2;
                        num4 = (ZZRefill() ? 1 : 0);
                        i = _zzCurrentPos;
                        num2 = _zzMarkedPos;
                        array = _zzBuffer;
                        num = _zzEndRead;
                        if (num4 != 0)
                        {
                            num11 = -1;
                            break;
                        }
                        char[] array3 = array;
                        int num12 = i;
                        i++;
                        num11 = array3[num12];
                    }
                    num4 = zZ_TRANS[zZ_ROWMAP[_zzState] + zZ_CMAP[num11]];
                    if (num4 == -1)
                    {
                        break;
                    }
                    _zzState = num4;
                    int num5 = zZ_ATTRIBUTE[_zzState];
                    if ((num5 & 1) == 1)
                    {
                        num6 = _zzState;
                        num2 = i;
                        if ((num5 & 8) == 8)
                        {
                            break;
                        }
                    }
                }
                _zzMarkedPos = num2;
                switch ((num6 >= 0) ? ZZ_ACTION[num6] : num6)
                {
                    case 12:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                        continue;
                    case 6:
                        return 6;
                    case 20:
                        YYBegin(4);
                        _stringBuilder.Append('\'');
                        continue;
                    case 10:
                        return 11;
                    case 3:
                        _sawWhitespace = false;
                        return 2;
                    case 18:
                        YYBegin(6);
                        _stringBuilder.Append('\'');
                        continue;
                    case 19:
                        YYBegin(8);
                        _stringBuilder.Append('"');
                        continue;
                    case 16:
                        Append();
                        continue;
                    case 4:
                        _sawWhitespace = false;
                        return 1;
                    case 21:
                        YYBegin(4);
                        _stringBuilder.Append('"');
                        continue;
                    case 9:
                        return 9;
                    case 2:
                        _sawWhitespace = true;
                        continue;
                    case 15:
                        YYBegin(0);
                        return 8;
                    case 17:
                        YYBegin(2);
                        return 10;
                    case 14:
                        YYBegin(4);
                        _stringBuilder.Length = 0;
                        return 9;
                    case 7:
                        return 5;
                    case 11:
                        YYBegin(2);
                        return 7;
                    case 13:
                        return 1;
                    case 1:
                        Unexpected();
                        continue;
                    case 5:
                        return 3;
                    case 8:
                        return 4;
                }
                if (num11 == -1 && _zzStartRead == _zzCurrentPos)
                {
                    _zzAtEOF = true;
                    return 0;
                }
                ZZScanError("Error: could not match input");
            }
        }
    }
}
